!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self)["@atomico/base-element"]=t()}(this,function(){"use strict";function e(e){return JSON.parse(e)}return class extends HTMLElement{constructor(){super(),this.props={},this.mounted=new Promise(e=>this.mount=e),this.unmounted=new Promise(e=>this.unmount=e)}connectedCallback(){this.mount()}disconnectedCallback(){this.unmount()}attributeChangedCallback(e,t,s){t!=s&&this.setProperty(e,s)}static get observedAttributes(){let e=this.observables||{},t=[],s=e=>{Object.defineProperty(this.prototype,e,{set(t){this.setProperty(e,t)},get(){return this.props[e]}})};for(let r in e){let e=r.replace(/([A-Z])/g,"-$1").toLowerCase();t.push(e),name in this.prototype||s(r)}return t}setProperty(t,s){t=t.replace(/-(\w)/g,(e,t)=>t.toUpperCase());let r,{observables:o}=this.constructor,n=o[t];try{if("string"==typeof s)switch(n){case Boolean:s=1==e(s||"true");break;case Number:s=Number(s);break;case Object:case Array:s=e(s)}}catch(e){r=!0}if(r||{}.toString.call(s)!=`[object ${n.name}]`)throw`the attribute [${t}] must be of the type [${n.name}]`;this.update({[t]:s})}update(e){}}});
//# sourceMappingURL=atomico-base-element.umd.js.map
